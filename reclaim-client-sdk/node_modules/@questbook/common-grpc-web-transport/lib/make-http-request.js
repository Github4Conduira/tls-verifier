"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeHttpRequest = void 0;
const http_parser_js_1 = require("http-parser-js");
function makeHttpRequest(opts) {
    var _a;
    const defaultPort = opts.secure ? 443 : 80;
    const log = (_a = opts.log) !== null && _a !== void 0 ? _a : false;
    const lines = [
        `${opts.method} ${opts.path} HTTP/1.1`,
        `Host: ${opts.host}`,
    ];
    const resParser = new http_parser_js_1.HTTPParser(http_parser_js_1.HTTPParser.RESPONSE);
    const tcpSocket = opts.makeSocket();
    const netSocket = opts.secure
        ? opts.makeTLSSocket(tcpSocket)
        : tcpSocket;
    if (opts.secure && log) {
        console.log('secure');
    }
    let pendingWrites = [];
    let sentInit = false;
    let sentContentLengthHeader = false;
    for (const key in opts.headers) {
        writeHeader(key, `${opts.headers[key]}`);
    }
    netSocket.connect({
        host: opts.host,
        port: opts.port ? +opts.port : defaultPort,
        noDelay: true,
        keepAlive: true,
    }, onConnect);
    resParser.onBody = (chunk, offset, length) => {
        chunk = chunk.subarray(offset, offset + length);
        if (log) {
            console.log('recv body', chunk);
        }
        // const data = 
        netSocket.emit('data-http', chunk);
    };
    resParser.onHeadersComplete = (info) => {
        const headers = {};
        for (let i = 0; i < info.headers.length; i += 2) {
            headers[info.headers[i].toString()] = info.headers[i + 1].toString();
        }
        if (log) {
            console.log('recv headers', info.statusCode, headers);
        }
        netSocket.emit('headers', info.statusCode, headers);
    };
    resParser.onMessageComplete = () => {
        if (log) {
            console.log('recv end');
        }
        netSocket.emit('end-http');
    };
    netSocket.on('data', data => {
        if (log) {
            console.log('recv ', data.toString());
        }
        resParser.execute(data);
    });
    return {
        onError(callback) {
            netSocket.on('error', callback);
        },
        onHeaders(callback) {
            netSocket.on('headers', callback);
        },
        onData(callback) {
            netSocket.on('data-http', callback);
        },
        onEnd(callback) {
            netSocket.on('end-http', callback);
        },
        end() {
            netSocket.end();
        },
        destroy() {
            netSocket.destroy();
        },
        write,
        writeHeader,
    };
    function write(content) {
        if (!sentContentLengthHeader) {
            writeHeader('transfer-encoding', 'chunked');
        }
        if (!sentInit) {
            const initData = lines.join('\r\n') + '\r\n\r\n';
            if (log) {
                console.log('sent init data', initData);
            }
            writeToSocket(initData);
            sentInit = true;
        }
        if (!sentContentLengthHeader) {
            writeToSocket(`${content.length.toString(16)}\r\n`);
        }
        writeToSocket(content);
        if (!sentContentLengthHeader) {
            writeToSocket(`\r\n0\r\n\r\n`);
        }
    }
    function writeHeader(key, value) {
        if (sentInit) {
            throw new Error('Cannot write header after init');
        }
        if (key.toLowerCase() === 'content-length') {
            sentContentLengthHeader = true;
        }
        lines.push(`${key}: ${value}`);
    }
    function writeToSocket(buff) {
        if (netSocket.connecting) {
            pendingWrites.push(buff);
        }
        else {
            netSocket.write(buff);
        }
    }
    function onConnect() {
        for (const pendingWrite of pendingWrites) {
            netSocket.write(pendingWrite);
        }
        pendingWrites = [];
    }
}
exports.makeHttpRequest = makeHttpRequest;
