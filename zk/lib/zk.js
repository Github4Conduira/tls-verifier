"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toUint8Array = exports.verifyProof = exports.generateProof = void 0;
const snarkjs = __importStar(require("snarkjs"));
const reclaim_crypto_sdk_1 = require("@questbookapp/reclaim-crypto-sdk");
const utils_1 = require("./utils");
// chunk size in 32-bit words
const CHUNK_SIZE = 16;
// cha-cha block size in 32-bit words
const BLOCK_SIZE = 16;
/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 *
 * @param privateInput private input to the circuit
 * will include the key, iv, and counter
 * @param pub public input to the circuit,
 * will include the ciphertext and redacted plaintext
 * @param zkParams ZK params -- verification key and circuit wasm
 */
async function generateProof({ key, iv, startCounter, }, pub, { zkey, circuitWasm }) {
    const keyU32 = toUintArray(Buffer.from(key));
    const nonce = toUintArray(Buffer.from(iv));
    const proofs = await chunkingPublicInputs(pub, async (ciphertext, _, i) => {
        const { proof, publicSignals } = await snarkjs.groth16.fullProve({
            key: Array.from(keyU32),
            nonce: Array.from(nonce),
            counter: startCounter + i * (CHUNK_SIZE / BLOCK_SIZE),
            in: Array.from(ciphertext),
        }, circuitWasm, zkey.data);
        return {
            proofJson: JSON.stringify(proof),
            decryptedRedactedCiphertext: (0, utils_1.makeUintArray)(publicSignals.slice(0, CHUNK_SIZE).map((x) => +x))
        };
    });
    return proofs;
}
exports.generateProof = generateProof;
/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
async function verifyProof(proofs, publicInput, zkey) {
    if (!zkey.json) {
        const zkeyJson = await snarkjs.zKey.exportVerificationKey(zkey.data);
        zkey.json = zkeyJson;
    }
    await chunkingPublicInputs(publicInput, async (redactedCiphertext, redactedPlaintext, i) => {
        // ensure that the redacted plaintext is congruent
        // with the decrypted redacted ciphertext,
        // so we know the proof is for this piece of text only
        if (!(0, reclaim_crypto_sdk_1.isRedactionCongruent)(Uint8Array.from(redactedPlaintext), Uint8Array.from(proofs[i].decryptedRedactedCiphertext))) {
            throw new Error(`redacted ciphertext (${i}) not congruent`);
        }
        // serialise to array of numbers for the ZK circuit
        const pubInputs = getSerialisedPublicInputs({
            ciphertext: redactedCiphertext,
            decryptedRedactedCiphertext: proofs[i].decryptedRedactedCiphertext
        });
        const chunkVerfied = await snarkjs.groth16.verify(zkey.json, pubInputs, JSON.parse(proofs[i].proofJson));
        if (!chunkVerfied) {
            throw new Error(`chunk ${i} not verified`);
        }
    });
}
exports.verifyProof = verifyProof;
/**
 * Serialise public inputs to array of numbers for the ZK circuit
 * the format is spread (output, ciphertext, redactedPlaintext)
 * @param inp
 */
function getSerialisedPublicInputs({ decryptedRedactedCiphertext, ciphertext }) {
    return [
        ...Array.from(decryptedRedactedCiphertext),
        ...Array.from(ciphertext),
    ];
}
async function chunkingPublicInputs({ ciphertext, redactedPlaintext }, code) {
    if (ciphertext.length !== redactedPlaintext.length) {
        throw new Error('ciphertext smaller than plaintext');
    }
    // pad to nearest 16 word chunk
    const ciphertextArray = toUintArray(ciphertext);
    const buffSize = Math.ceil(ciphertextArray.length / CHUNK_SIZE) * CHUNK_SIZE;
    const ciphertextChunks = chunkArray(padArray(ciphertextArray, buffSize), CHUNK_SIZE);
    const redactedPlaintextChunks = chunkArray(padArray(toUintArray(redactedPlaintext), buffSize), CHUNK_SIZE);
    const result = [];
    for (let i = 0; i < ciphertextChunks.length; i++) {
        // redact ciphertext if plaintext is redacted
        // to prepare for decryption in ZK circuit
        // the ZK circuit will take in the redacted ciphertext,
        // which shall produce the redacted plaintext
        for (let j = 0; j < ciphertextChunks[i].length; j++) {
            if (redactedPlaintextChunks[i][j] === reclaim_crypto_sdk_1.REDACTION_CHAR_CODE) {
                ciphertextChunks[i][j] = reclaim_crypto_sdk_1.REDACTION_CHAR_CODE;
            }
        }
        const r = await code(ciphertextChunks[i], redactedPlaintextChunks[i], i);
        result.push(r);
    }
    return result;
}
/**
 * Convert a UintArray (uint32array) to a Uint8Array
 */
function toUint8Array(buf) {
    const arr = Buffer.alloc(buf.length * 4);
    for (let i = 0; i < buf.length; i++) {
        arr.writeUInt32LE(buf[i], i * 4);
    }
    return arr;
}
exports.toUint8Array = toUint8Array;
function toUintArray(buf) {
    buf = Buffer.isBuffer(buf) ? buf : Buffer.from(buf);
    const arr = (0, utils_1.makeUintArray)(buf.length / 4);
    for (let i = 0; i < arr.length; i++) {
        arr[i] = buf.readUInt32LE(i * 4);
    }
    return arr;
}
function padArray(buf, size) {
    return (0, utils_1.makeUintArray)([
        ...Array.from(buf),
        ...new Array(size - buf.length).fill(reclaim_crypto_sdk_1.REDACTION_CHAR_CODE)
    ]);
}
function chunkArray(buffer, chunkSize) {
    const chunks = [];
    for (let i = 0; i < buffer.length; i += chunkSize) {
        chunks.push(buffer.slice(i, i + chunkSize));
    }
    return chunks;
}
